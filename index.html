<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticky Stop Slime</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #020617;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
        }

        #ui-left {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #f8fafc;
            pointer-events: none;
            z-index: 20;
        }

        #ui-right {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.8);
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
            z-index: 20;
        }

        #restart-btn {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            display: none;
            background: #f43f5e;
            color: white;
            z-index: 30;
        }

        #msg {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f1f5f9;
            font-size: 3.5rem;
            text-align: center;
            display: none;
            font-weight: bold;
            z-index: 30;
        }
    </style>
</head>

<body>
    <div id="ui-left">
        <h1 id="score">0m</h1>
        <p>A / D to MOVE | SPACE to JUMP (Strength: 128)</p>
    </div>
    <div id="ui-right">
        <input type="color" id="colorPicker" value="#10b981">
    </div>
    <div id="msg">CRUSHED!</div>
    <button id="restart-btn">RESTART</button>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const msgEl = document.getElementById('msg');
        const restartBtn = document.getElementById('restart-btn');
        const colorPicker = document.getElementById('colorPicker');

        let width, height, groundY;
        let particles = [];
        let constraints = [];
        let pistons = [];
        let distance = 0;
        let gameOver = false;
        let keys = {};

        // --- PHYSICS TWEAKS ---
        const PARTICLE_COUNT = 20;
        const RADIUS = 60;
        const SKIN_STIFFNESS = 0.25;
        const INTERNAL_STIFFNESS = 0.008;
        const BASE_FRICTION = 0.96;    // Glides while moving
        const STOP_FRICTION = 0.85;    // "Sticky" stop when keys released
        const GRAVITY = 0.85;
        const JUMP_FORCE = 1024;
        const MOVE_SPEED = 2.0;
        const MAX_VEL = 35;

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            groundY = height - 60;
            particles = [];
            constraints = [];
            pistons = [];
            distance = 0;
            gameOver = false;
            msgEl.style.display = 'none';
            restartBtn.style.display = 'none';

            const startX = 200;
            const startY = groundY - 100;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                particles.push({
                    x: startX + Math.cos(angle) * RADIUS,
                    y: startY + Math.sin(angle) * RADIUS,
                    oldX: startX + Math.cos(angle) * RADIUS,
                    oldY: startY + Math.sin(angle) * RADIUS
                });
            }

            // Connect particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                constraints.push({ p1: particles[i], p2: particles[(i + 1) % PARTICLE_COUNT], len: (Math.PI * 2 * RADIUS) / PARTICLE_COUNT, type: 'skin' });
                let opp = (i + Math.floor(PARTICLE_COUNT / 2)) % PARTICLE_COUNT;
                constraints.push({ p1: particles[i], p2: particles[opp], len: RADIUS * 2, type: 'int' });
            }

            for (let i = 0; i < 5; i++) spawnPiston(1000 + i * 850);
        }

        function spawnPiston(x) {
            pistons.push({ x, h: 0, targetH: groundY - 30, state: 'wait', timer: Math.random() * 60 });
        }

        function update() {
            let avgX = 0, avgY = 0;
            // Determine friction based on input
            const isMoving = keys['d'] || keys['a'] || keys['arrowright'] || keys['arrowleft'];
            const currentFriction = isMoving ? BASE_FRICTION : STOP_FRICTION;

            particles.forEach(p => {
                let vx = (p.x - p.oldX) * currentFriction;
                let vy = (p.y - p.oldY) * currentFriction;

                vx = Math.min(Math.max(vx, -MAX_VEL), MAX_VEL);
                vy = Math.min(Math.max(vy, -MAX_VEL), MAX_VEL);

                p.oldX = p.x; p.oldY = p.y;

                if (!gameOver) {
                    if (keys['d'] || keys['arrowright']) p.x += MOVE_SPEED;
                    if (keys['a'] || keys['arrowleft']) p.x -= MOVE_SPEED;
                    if (keys[' '] && p.y >= groundY - 5) {
                        p.y -= JUMP_FORCE * 0.12;
                    }
                }

                p.x += vx;
                p.y += vy + GRAVITY;

                // Ground, Walls, and Ceiling Bounds
                if (p.y > groundY) { p.y = groundY; p.x -= (p.x - p.oldX) * 0.4; } // Floor friction
                if (p.y < 10) { p.y = 10; p.oldY = p.y + 2; } // Ceiling bounce
                if (p.x < 10) p.x = 10;
            });

            // Solver for softness
            for (let s = 0; s < 12; s++) {
                constraints.forEach(c => {
                    const dx = c.p2.x - c.p1.x, dy = c.p2.y - c.p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const stiff = c.type === 'skin' ? SKIN_STIFFNESS : INTERNAL_STIFFNESS;
                    const diff = (c.len - dist) / dist * (gameOver ? 0.3 : stiff);
                    c.p1.x -= dx * diff; c.p1.y -= dy * diff;
                    c.p2.x += dx * diff; c.p2.y += dy * diff;
                });
                particles.forEach(p => { if (p.y > groundY) p.y = groundY; });
            }

            particles.forEach(p => { avgX += p.x; avgY += p.y; });
            const cx = avgX / PARTICLE_COUNT;

            pistons.forEach(p => {
                p.timer++;
                if (p.state === 'wait' && p.timer > 70) p.state = 'drop';
                if (p.state === 'drop') { p.h += 55; if (p.h >= p.targetH) p.state = 'rise'; }
                if (p.state === 'rise') { p.h -= 6; if (p.h <= 0) { p.state = 'wait'; p.timer = 0; } }

                particles.forEach(part => {
                    if (part.x > p.x && part.x < p.x + 160 && part.y < p.h) {
                        if (Math.abs(part.x - cx) < 25 && !gameOver) {
                            gameOver = true;
                            msgEl.style.display = 'block';
                            restartBtn.style.display = 'block';
                        }
                        part.y = p.h + 5;
                    }
                });
            });

            if (cx > 400) {
                const s = (cx - 400) * 0.2;
                particles.forEach(p => { p.x -= s; p.oldX -= s; });
                pistons.forEach(p => p.x -= s);
                if (!gameOver) distance += s;
            }

            if (pistons[0] && pistons[0].x < -300) {
                pistons.shift();
                spawnPiston(pistons[pistons.length - 1].x + 850);
            }
            scoreEl.innerText = Math.floor(distance / 10) + "m";
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, groundY, width, 60);

            pistons.forEach(p => {
                ctx.fillStyle = '#f43f5e';
                ctx.fillRect(p.x, 0, 160, p.h);
            });

            ctx.beginPath();
            ctx.moveTo(particles[0].x, particles[0].y);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let p = particles[i], next = particles[(i + 1) % PARTICLE_COUNT];
                ctx.quadraticCurveTo(p.x, p.y, (p.x + next.x) / 2, (p.y + next.y) / 2);
            }
            ctx.closePath();
            ctx.fillStyle = colorPicker.value;
            ctx.fill();
            ctx.strokeStyle = "rgba(255,255,255,0.8)";
            ctx.lineWidth = 3;
            ctx.stroke();

            update();
            requestAnimationFrame(draw);
        }

        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        restartBtn.onclick = init;
        init();
        draw();
    </script>
</body>

</html>
